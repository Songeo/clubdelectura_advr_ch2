---
title: "Club de lectura - Advanced RğŸ“š"
author: "<br/>RLadies MX ğŸ‡²ğŸ‡½"
output: html_notebook
---

----

# Club de lectura

Esta es la parte 1 del club de lectura R Ladies MÃ©xico

Estamos leyendo **Advanced R** de Hadley Wickham.

https://adv-r.hadley.nz/

![](img/bookpage_short.png){width=30%}



----

# Capitulo 2. Nombres y valores

## Ejercicios


### 2.1 IntroducciÃ³n  
<!--  (Introduction) -->

**Quiz**

1. Dado el siguiente marco de datos, Â¿cÃ³mo puedo crear una nueva columna llamada "3" que contiene la suma de 1 y 2? Solo puedes usar `$`, no `[[`. Â¿QuÃ© hace que 1, 2 y 3 sean complicados como nombres de variables?

```{r}
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
```



2. En el siguiente cÃ³digo, Â¿cuÃ¡nta memoria ocupa `y`?
```{r}
x <- runif(1e6)
y <- list(x, x, x)
```


3. En el siguiente ejemplo, Â¿en quÃ© lÃ­nea `a` es una copiado?
```{r}
a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```



### 2.2 Binding basics
<!--  (Binding Basics) -->

1. Explica la relaciÃ³n entre `a`, `b`, `c` y `d` en el cÃ³digo siguiente:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```


2. El siguiente cÃ³digo accede a la funciÃ³n `mean()` de varias formas. Â¿Apuntan todas al mismo objeto de funciÃ³n subyacente? Usa `lobstr::obj_addr()` para verificarlo.


```{r}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

3. De forma predeterminada, R base importa funciones, como `read.csv()`, que convertirÃ¡n automÃ¡ticamente los nombres **no sintÃ¡cticos** en **sintÃ¡cticos**. Â¿Por quÃ© puede ser esto problemÃ¡tico? Â¿QuÃ© opciÃ³n permite eludir este comportamiento?


4. Â¿QuÃ© reglas usa `make.names()` para convertir nombres no sintÃ¡cticos en sintÃ¡cticos?

5. SimplifiquÃ© ligeramente las reglas que gobiernan los nombres sintÃ¡cticos. Â¿Por quÃ© `.123e1` no es un nombre sintÃ¡ctico? Consulta `?Make.names` para obtener todos los detalles.


### 2.3 Copy-on-modify
<!--  (Copy-on-modify) -->

1. Â¿Por quÃ© `tracemem(1:10)` no es Ãºtil?

2. Explica por quÃ© `tracemem()` muestra dos copias cuando ejecuta este cÃ³digo. Sugerencia: observa cuidadosamente la diferencia entre este cÃ³digo y el cÃ³digo que se mostrÃ³ anteriormente en la secciÃ³n.

```{r}
x <- c(1L, 2L, 3L)
tracemem(x)

x[[3]] <- 4
```

3. Haz un dibujo de la relaciÃ³n entre los siguientes objetos:

```{r}
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)
```

4. Â¿QuÃ© sucede cuando ejecutas el siguiente cÃ³digo?

```{r}
x <- list(1:10)
x[[2]] <- x
```

DibÃºjalo. 



### 2.4 Object size
<!--  (Object size) -->

1. En el siguiente ejemplo, Â¿por quÃ© `object.size(y)` y `obj_size(y)` son tan  diferentes? Consulta la documentaciÃ³n de `object.size()`.

```{r}
y <- rep(list(runif(1e4)), 100)

object.size(y)
#> 8005648 bytes
obj_size(y)
#> 80,896 B
```

2. Considera la siguiente lista. Â¿Por quÃ© su tamaÃ±o es algo engaÃ±oso?

```{r}
funs <- list(mean, sd, var)
obj_size(funs)
#> 17,608 B
```

3. predice la salida del siguiente cÃ³digo:

```{r}
a <- runif(1e6)
obj_size(a)

b <- list(a, a)
obj_size(b)
obj_size(a, b)

b[[1]][[1]] <- 10
obj_size(b)
obj_size(a, b)

b[[2]][[1]] <- 10
obj_size(b)
obj_size(a, b)
```



### 2.5 Modify-in-place
<!--  (Modify-in-place) -->

1. Explica por quÃ© el siguiente cÃ³digo no creao un lista circular:

```{r}
x <- list()
x[[1]] <- x
```

2. Envuelva los dos mÃ©todos para restar medianas en dos funciones, luego use  `bench package17`  para comparar sus velocidades. Â¿CÃ³mo cambia el rendimiento a medida que aumenta el nÃºmero de columnas?

Wrap the two methods for subtracting medians into two functions, then use the â€˜benchâ€™ package17 to carefully compare their speeds. How does performance change as the number of columns increase?

3. Â¿QuÃ© sucede si intentas utilizar `tracemem()` en un ambiente?

